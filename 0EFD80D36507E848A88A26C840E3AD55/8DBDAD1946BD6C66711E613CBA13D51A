#region License Information
/*
 * This file is part of HEAL.CFR which is licensed under the MIT license.
 * See the LICENSE file in the project root for more information.
 */
#endregion

using HEAL.CFR;
using System;
using System.Diagnostics;
using System.Linq; // 用于 .Variance(), .Max() 等


namespace Demo {
  class Program {

    // --- 辅助函数：随机打乱二维数组的行 ---
    static void Shuffle(Random rand, double[,] array) {
      int rows = array.GetLength(0);
      int cols = array.GetLength(1);
      for (int i = rows - 1; i > 0; i--) {
        int j = rand.Next(i + 1);
        // 交换第 i 行和第 j 行
        for (int c = 0; c < cols; c++) {
          double temp = array[i, c];
          array[i, c] = array[j, c];
          array[j, c] = temp;
        }
      }
    }

    // --- 辅助函数：从原始数据创建特征矩阵 ---
    static (double[,] xy, double[] y) CreateFeatureMatrix(double[,] rawData, int numPolyFeatures) {
        int n = rawData.GetLength(0);
        var xy = new double[n, numPolyFeatures + 1];
        var y = new double[n];

        for (int i = 0; i < n; i++) {
            double x_base = rawData[i, 0];
            double current_y = rawData[i, 1];
            
            y[i] = current_y;
            xy[i, 0] = x_base;

            for (int p = 1; p < numPolyFeatures; p++) {
                xy[i, p] = xy[i, p - 1] * x_base;
            }
            xy[i, numPolyFeatures] = current_y;
        }
        return (xy, y);
    }


    static void Main(string[] args) {
      // ##################################################################
      // #                         数据定义与配置                         #
      // ##################################################################

      // --- 用户可配置参数 ---
      int numPolyFeatures = 2;      // 要使用的多项式特征数量
      double trainSplitRatio = 0.1; //
      var rand = new Random(1234); // 使用固定的随机种子以保证结果可复现

      // --- 直接在此处输入您的数据 ---
      // 注意：x值可以是任意大数值，下面的代码会自动处理
      double[,] rawData =  {
 
};

      // ##################################################################
      // #            新增：数据归一化 (解决数值范围过大问题)             #
      // ##################################################################

      Console.WriteLine("正在对数据进行归一化处理...");
      int rowCount = rawData.GetLength(0);

      // 1. 找到 x 列（第0列）的最大值和最小值
      double xMin = rawData[0, 0];
      double xMax = rawData[0, 0];
      for (int i = 1; i < rowCount; i++) {
          if (rawData[i, 0] < xMin) xMin = rawData[i, 0];
          if (rawData[i, 0] > xMax) xMax = rawData[i, 0];
      }

      // 2. 应用 Min-Max 缩放公式: x_scaled = (x - x_min) / (x_max - x_min)
      //    这将把 x 的值缩放到 [0, 1] 区间
      double range = xMax - xMin;
      if (range > 0) { // 避免除以零
          for (int i = 0; i < rowCount; i++) {
              rawData[i, 0] = (rawData[i, 0] - xMin) / range;
          }
          Console.WriteLine($"x 值已被缩放到 [0, 1] 区间。");
      }

      // ##################################################################
      // #                      数据划分与准备                            #
      // ##################################################################

      Console.WriteLine($"\n总数据量: {rawData.GetLength(0)}");

      // 1. 随机打乱所有数据
      Shuffle(rand, rawData);

      // 2. 计算训练集和测试集的大小（固定90%为测试集，10%为训练集）
      int totalSize = rawData.GetLength(0);
      int testSize = (int)(totalSize * 0.9); // 90% 测试集
      int trainSize = totalSize - testSize;  // 10% 训练集

      Console.WriteLine($"划分比例: 10% 训练 / 90% 测试");
      Console.WriteLine($"训练集大小: {trainSize}, 测试集大小: {testSize}");

      // 3. 创建训练集和测试集数组
      var trainData = new double[trainSize, 2];
      var testData = new double[testSize, 2];

      for(int i=0; i<trainSize; i++) {
        trainData[i, 0] = rawData[i, 0];
        trainData[i, 1] = rawData[i, 1];
      }
      for(int i=0; i<testSize; i++) {
        testData[i, 0] = rawData[trainSize + i, 0];
        testData[i, 1] = rawData[trainSize + i, 1];
      }

      // 4. 分别为训练集和测试集创建特征矩阵
      var (test_xy, test_y) = CreateFeatureMatrix(testData, numPolyFeatures);
      // 固定测试集，训练集可变

      // ##################################################################
      // #         用不同规模的训练子集多次训练模型并输出结果              #
      // ##################################################################
      int[] trainPercents = new int[] { 100, 80, 60, 40, 20, 10, 5 };
      foreach (var percent in trainPercents) {
        int curTrainSize = Math.Max(1, trainSize * percent / 100);
        var curTrainData = new double[curTrainSize, 2];
        Array.Copy(trainData, curTrainData, curTrainSize * 2);
        var (curTrain_xy, curTrain_y) = CreateFeatureMatrix(curTrainData, numPolyFeatures);
        var train_yVar = MathNet.Numerics.Statistics.ArrayStatistics.Variance(curTrain_y);
        var param = CFR.DefaultParameters;
        param.depth = 2;
        var bestObjValue = double.PositiveInfinity;
        var bestMSE = double.PositiveInfinity;
        ContinuedFraction bestModel = null;
        var iter = 0;
        var sw = new Stopwatch();
        void writeCurrentObjectiveValue(Agent obj) {
          iter++;
          if (obj.pocketObjValue < bestObjValue) {
            bestObjValue = obj.pocketObjValue;
            bestModel = obj.pocket.Clone();
          }
          var curMSE = CFR.MeanSquaredError(obj.pocket, curTrain_xy);
          if (curMSE < bestMSE) bestMSE = curMSE;
        }
        Console.WriteLine($"\n--- 用 {percent}% ({curTrainSize} 条) 训练集训练 ---");
        sw.Start();
        CFR.Run(param, curTrain_xy, new Random(rand.Next()), null, writeCurrentObjectiveValue);
        sw.Stop();
        if (bestModel != null && curTrain_y.Length > 0 && test_y.Length > 0) {
          double finalTrainMSE = CFR.MeanSquaredError(bestModel, curTrain_xy);
          double testMSE = CFR.MeanSquaredError(bestModel, test_xy);
          double finalTrainRMSE = Math.Sqrt(finalTrainMSE);
          double train_y_max = curTrain_y.Max();
          double finalTrainNRMSE_max = train_y_max != 0 ? finalTrainRMSE / train_y_max : 0;
          double testRMSE = Math.Sqrt(testMSE);
          double test_y_max = test_y.Max();
          double testNRMSE_max = test_y_max != 0 ? testRMSE / test_y_max : 0;
          Console.WriteLine($"训练集MSE={finalTrainMSE}, 测试集MSE={testMSE}");
          Console.WriteLine($"训练集NRMSE={finalTrainNRMSE_max:P2}, 测试集NRMSE={testNRMSE_max:P2}");
        } else {
          Console.WriteLine("未能找到有效的模型或数据集为空。");
        }
      }

      // ##################################################################
      // #                     在训练集上训练模型                         #
      // ##################################################################

      var train_yVar = MathNet.Numerics.Statistics.ArrayStatistics.Variance(train_y);
      var param = CFR.DefaultParameters;
      param.depth = 2;

      var bestObjValue = double.PositiveInfinity;
      var bestMSE = double.PositiveInfinity;
      ContinuedFraction bestModel = null;
      var iter = 0;
      var sw = new Stopwatch();

      void writeCurrentObjectiveValue(Agent obj) {
        iter++;
        if (obj.pocketObjValue < bestObjValue) {
          bestObjValue = obj.pocketObjValue;
          bestModel = obj.pocket.Clone();
        }
        var curMSE = CFR.MeanSquaredError(obj.pocket, train_xy);
        if (curMSE < bestMSE) bestMSE = curMSE;
        Console.WriteLine($"{iter,5} {sw.Elapsed.TotalSeconds,5:f1} {obj.pocketObjValue,10:e3} {bestObjValue,10:e3} {curMSE,10:e3} {bestMSE,10:e3} {curMSE / train_yVar,10:e3} {bestMSE / train_yVar,10:e3}");
      }

      Console.WriteLine("\n--- 开始在训练集上进行训练 ---");
      Console.WriteLine($"{"Iter",5} {"Sec",5} {"CurObj",10} {"BestObj",10} {"TrainMSE",10} {"BestTrainMSE",10} {"TrainNMSE",10} {"BestTrainNMSE",10}");
      sw.Start();
      CFR.Run(param, train_xy, new Random(rand.Next()), null, writeCurrentObjectiveValue);

      Console.WriteLine("\n--- 训练完成 ---");

      // ##################################################################
      // #             在训练集与测试集上评估最终模型                     #
      // ##################################################################
      if (bestModel != null && train_y.Length > 0 && test_y.Length > 0)
      {
        Console.WriteLine("\n找到的最佳模型表达式:");
        Console.WriteLine(bestModel);

        // --- 训练集表现 ---
        double finalTrainMSE = CFR.MeanSquaredError(bestModel, train_xy);
        double finalTrainRMSE = Math.Sqrt(finalTrainMSE);
        double train_y_max = train_y.Max();
        double finalTrainNRMSE_max = train_y_max != 0 ? finalTrainRMSE / train_y_max : 0;

        Console.WriteLine($"\n--- 训练集表现 (In-Sample Performance) ---");
        Console.WriteLine($"最终训练集 MSE                  = {finalTrainMSE}");
        Console.WriteLine($"最终训练集 NMSE (按方差归一化) = {finalTrainMSE / train_yVar}");
        Console.WriteLine($"最终训练集 NRMSE (按最大值归一化) = {finalTrainNRMSE_max:P2}");

        // --- 测试集表现 ---
        double testMSE = CFR.MeanSquaredError(bestModel, test_xy);
        var test_yVar = MathNet.Numerics.Statistics.ArrayStatistics.Variance(test_y);
        double testRMSE = Math.Sqrt(testMSE);
        double test_y_max = test_y.Max();
        double testNRMSE_max = test_y_max != 0 ? testRMSE / test_y_max : 0;

        Console.WriteLine($"\n--- 测试集表现 (Generalization Performance) ---");
        Console.WriteLine($"最终测试集 MSE                  = {testMSE}");
        Console.WriteLine($"最终测试集 NMSE (按方差归一化) = {testMSE / test_yVar}");
        Console.WriteLine($"最终测试集 NRMSE (按最大值归一化) = {testNRMSE_max:P2}");

      } else {
        Console.WriteLine("未能找到有效的模型或数据集为空。");
      }
    }
  }
}